#!/usr/bin/env python

import numpy as np
import MDAnalysis as mda
import sys
import getopt
import matplotlib.pyplot as pyp
import pandas as pd
import plotly as py
import plotly.offline as offline #import download_plotlyjs, init_notebook_mode, plot, iplot
import plotly.graph_objs as go
import os
import time 
import shutil 

#NOTE TO SELF. If you are comparing to gromacs or something bear in mind that this gives results that are equivalent to 180-this_angle. This is due to the definition of vec1 and vec_temp, which are
#defined as vec_1= np.array(pos_at_2 - pos_at_1) here, but the other way around in gromacs

instructions = "This program will print the angles between the z axis and one or two vectors specified by the user. vec1 and vec2 are specified giving the a couple of atoms \"A1 A2\" that defines the vector. The program is invoked as:  \n" + sys.argv[0] + "  --vec1=\"A1 A2\" --vec2=\"A3 A4\" -s file.tpr -f traj.xtc -o outputname\n \n This will generate a file angles_outputname.dat that contains the angles vs time and a angles_outputname.png which plots them vs time"
print("\n")
print(instructions)
print("\n")

try:
    options, files = getopt.getopt(sys.argv[1:], 's:f:o:',['vec1=','vec2=','s=','f=','o='])  	#here i read the options and assign the values to the "options" variable  
except getopt.GetoptError:
    print("\n")
    sys.stderr.write("Error: you probably inserted a flag that isn't there or some files are missing")
    print("\n")
    raise SystemExit

for opt, val in options:  						#here i assign each option to a variable to use in the script	
    
    if opt == '--vec1':
        vec1=val
            
    if opt == '--vec2':
        vec2=val
    
    if opt == '-s':
        topol=val.lstrip()
    
    if opt == '-f':
        traj=val.lstrip()
    
    if opt == '-o':
	outputname=val.lstrip()

u=mda.Universe(topol, traj)
Angle1=[]
Angle2=[]
Ts=[]

f=open(outputname+".dat", 'w')                     #open the file with append option. CORRECT THIS WITH WRITE!
f.write("### This file was generated by the invoking: "+sys.argv[0]+" --vec1=\"%s\" --vec2=\"%s\"  -s %s -f %s -o %s  \n \n" % (vec1, vec2, topol , traj , outputname))
for ts in u.trajectory:
  pos_at_1=np.array(list(u.select_atoms("bynum "+str(vec1)).positions[0]))  #select the atoms
  pos_at_2=np.array(list(u.select_atoms("bynum "+str(vec1)).positions[1])) 
  pos_at_3=np.array(list(u.select_atoms("bynum "+str(vec2)).positions[0]))
  pos_at_4=np.array(list(u.select_atoms("bynum "+str(vec2)).positions[1]))
  #print(pos_at_1)
  vec_z= np.array([0,0,1])                              #define z axis and vec1
  vec_1= np.array(pos_at_2 - pos_at_1)                         #this will be vec1
  vec_temp= np.array(pos_at_4 - pos_at_3)                      #define a temporary vec_temp for the cross product to find vec_2 
  vec_2= np.cross(vec_1,vec_temp)                       #->remember here that a x b =! b x a, b x a = -a x b. So this vector should be pointing INTO the plane of the molecule
  norm_vec_z= np.sqrt(np.dot(vec_z, vec_z))             #the norms are for calculating the angles 
  norm_vec_1= np.sqrt(np.dot(vec_1, vec_1))
  norm_vec_2= np.sqrt(np.dot(vec_2, vec_2))
  angle_1=np.rad2deg(np.arccos((np.dot(vec_1,vec_z))/(norm_vec_1*norm_vec_z))) #angles are calculated with the formula
  angle_2=np.rad2deg(np.arccos((np.dot(vec_2,vec_z))/(norm_vec_2*norm_vec_z))) #to find an angle between 2 vectors
  Angle1.append(angle_1)
  Angle2.append(angle_2)
  Ts.append(ts.time)
#  if ts.time == 0 :                            #if its the first step it empties the file
#    f.seek(0)                                  #with this
#    f.truncate()                               #and this line
#    f.write("### This file was generated by the invoking: "+sys.argv[0]+" --vec1=\"%s\" --vec2=\"%s\"  -s %s -f %s -o %s  \n \n" % (vec1, vec2, topol , traj , outputname)) #spaces are just left inbetween 
  f.write("%s\t%s\t%s\n" % (int(ts.time), float(angle_1), float(angle_2))) #spaces are just left inbetween 
f.close() 

##PLOT THE GRAPH
df=pd.read_table(outputname+".dat",skiprows=1 ,names=["time","angle1","angle2"])
prob_matrix=np.zeros((180,180))

#read the file and fill the prob_matrix adding 1 every time a couple of angle occurs
for index, line in df.iterrows():
        if (int(round(line["angle1"])) == 180):
            line["angle1"]=0
        if (int(round(line["angle2"])) == 180):
            line["angle2"]=0
        else:
            prob_matrix[int(round(line["angle1"])),int(round(line["angle2"]))]+=1
        
#normalize the prob_matrix to sum up to 1
prob_matrix=prob_matrix/float(df.shape[0])

#prepare the reference matrix, 16381 is the number of slots inside the diamond.It has been obtained shamefully by
#counting the boxes with the following script:
counter =0
# for i in range(181):
#     for j in range(181):             #vTHIS DOWN HERE IS THE CONDITION OF EXISTENCE OF THE DIAMONDv
#         cond1=np.round(abs(np.deg2rad(i)-np.deg2rad(90)),4)
#         cond2=np.round(abs(np.deg2rad(j)-np.deg2rad(90)),4)
#         cond3=np.round(np.deg2rad(90),4)
#         if (np.round(cond1 + cond2,4) ) <= cond3: #diamond condition
#             counter+=1
# print counter

#this is because the ref_matrix has to have a flat probability in every slot, with an absolute value of
#NPOINTS/NOCCUPIEDSLOTS in every slot. Since the condition of existence is influenced by the numerical approximation
#i decided to count like an ape. So here is the ref_matrix:

ref_matrix=np.zeros((180,180))
for i in range(180):
    for j in range(180):
        if (abs(np.deg2rad(i) - np.deg2rad(90)) + abs(np.deg2rad(j)-np.deg2rad(90))) <= np.deg2rad(90):
            ref_matrix[i,j]=(float(df.shape[0])/16381)

#and here i normalize it
ref_matrix=ref_matrix/float(df.shape[0])

#now i use my boy Joriki analytical correction for the density of the states.
#this first part is to bin the data, so that i don't divide by sin(0) and to have an histogram generally
for i in range(180):
    for j in range(180):
        if i == 0:
            i_ndex=0.25
        if j == 0:
            j_ndex=0.25
        if i == 180:
            i_ndex=179.75
        if j == 180:
            j_ndex=179.75
        else:
            i_ndex=i
            j_ndex=j

#Here i impose the diamond existance condition, which would imply that the radicand is >=0, if this is true and then
#if the denominator is not zero i scale the value of prob_matrix by the analytical correction

        cond1=np.round(abs(np.deg2rad(i)-np.deg2rad(90)),4)
        cond2=np.round(abs(np.deg2rad(j)-np.deg2rad(90)),4)
        cond3=np.round(np.deg2rad(90),4)
        if (np.round(cond1 + cond2,4) ) <= cond3: #diamond condition, if this is true...

            cos2i=np.round((np.cos(np.deg2rad(i_ndex)))**2,4)
            cos2j=np.round((np.cos(np.deg2rad(j_ndex)))**2,4)
            sini=np.round(np.sin(np.deg2rad(i_ndex)),4)
            sinj=np.round(np.sin(np.deg2rad(j_ndex)),4)
            radicand=np.round(1-(cos2i+cos2j),4)
            denominator= sini*sinj
            if (denominator) != 0:                #...and this is true:
                prob_matrix[i,j]= prob_matrix[i,j] * np.sqrt(radicand)/denominator

flatness=0
diff_matrix=np.zeros((180,180))

for i in range(180):
    for j in range(180):
        diff_matrix[i,j]=(prob_matrix[i,j]-ref_matrix[i,j])**2
        flatness += np.sqrt(diff_matrix[i,j])
print flatness

dfmat=pd.DataFrame(prob_matrix)
data = [

    go.Surface(
        z=dfmat.as_matrix()
    )
]
layout = go.Layout(
    title=outputname
)
fig = go.Figure(data=data, layout=layout)
py.offline.plot(fig)
